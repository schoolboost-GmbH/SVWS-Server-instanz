import groovy.json.JsonSlurper
import groovy.xml.XmlSlurper
import svws.gradle.scripts.FileUtils

dependencies {
	implementation project(':svws-server-app')
}

def buildDirPath = layout.buildDirectory.get()
def config = file("${rootDir}/config/tests/config.json").exists()
		? new JsonSlurper().parse(file("${rootDir}/config/tests/config.json"))
		: new JsonSlurper().parse(file("${rootDir}/config/tests/config_default.json"))

ext {
	def APP_BASE_IMAGE_NAME
	def CONTAINER_NAME_SUFFIX
}

tasks.register('copyWebclientBuildArtefacts', Copy) {
	description = 'Kopiert die SVWS Client Artefakte'
	dependsOn ':svws-webclient:client:doZip'
	from "${rootDir}/svws-webclient/client/build/SVWS-Client.zip"
	into "./build"
}

tasks.register('copyAdminclientBuildArtefacts', Copy) {
	description = 'Kopiert die SVWS Admin Client Artefakte'
	dependsOn ':svws-webclient:client:doZip'
	from "${rootDir}/svws-webclient/admin/build/SVWS-Admin-Client.zip"
	into "./build"
}


/**
 * Dieser Task kopiert die Laufzeit-Abhängigkeiten in das angegebene Build-Verzeichnis,
 * wobei bestimmte JAR-Dateien ausgeschlossen oder eingeschlossen werden.
 */
tasks.register('copyJavaBuildArtefacts', Copy) {
	description = 'Kopiert die Laufzeit-Abhängigkeiten in das Build-Verzeichnis'
	dependsOn 'copyWebclientBuildArtefacts'
	dependsOn 'copyAdminclientBuildArtefacts'

	into "$buildDirPath/extLib"

	into("lib/") {
		from(configurations.runtimeClasspath) {
			exclude "svws-*.jar"
		}
	}
	into("/") {
		from(configurations.runtimeClasspath) {
			include "svws-*.jar"
		}
	}
}


tasks.register('buildAppBaseDockerImage', Exec) {
	description = 'Erstellen des App-Base Docker-Images für die Testumgebung'
	dependsOn 'generateAppBaseDockerfile'
	commandLine 'docker', 'build', '-t', "${APP_BASE_IMAGE_NAME}", '-f', "${buildDirPath}/docker/app.base.dockerfile", '.'
}

/**
 * Dieser Task generiert die Dockerfile-Datei für die Testumgebung. Dabei wird ein Template geladen und entsprechende Platzhalter durch Variablen in Gradle ersetzt.
 */
tasks.register('generateAppBaseDockerfile') {
	description = 'Generiert die Dockerfile-Datei für das App-Base Image'
	dependsOn 'copyJavaBuildArtefacts'

	def templateDockerfile = file('templates/docker/template.app.base.dockerfile')
	def outputDockerfile = file("${buildDirPath}/docker/app.base.dockerfile")

	def DOCKER_REGISTRY_URL = System.getenv('CI_SERVER') != null ? config.dockerRegistry : "docker.io"

	doFirst {
		mkdir "${buildDirPath}/docker"
	}

	doLast {
		def replacements = [
				'GRADLE_PLACEHOLDER_DOCKER_REG_URL': "${DOCKER_REGISTRY_URL}"
		]

		FileUtils.replaceFilePlaceholderWithValues(templateDockerfile, outputDockerfile, replacements)
	}
}


/**
 * Diese Task vergleicht die Schlüssel der Konfigurationsdateien der SVWS-App und ihrer Docker-Testcontainer.
 * Wenn Unterschiede festgestellt werden, wird eine GradleException ausgelöst.
 *
 * @throws GradleException wenn die Konfigurationsdateien inkonsistent sind.
 */
tasks.register('checkIfConfigFilesAreConsistent') {
	description = 'Wirft einen Fehler wenn die Konfigurationstemplates für den Server oder die Container unterschiedlich sind.'

	def appConfigTemplatePath = '../svws-server-app/src/main/resources/svwsconfig.json.example'
	def dockerTestContainerConfigTemplatePath = './templates/config/svws_config.json.template'
	def appConfigTemplateFile = file(appConfigTemplatePath)
	def dockerTestContainerConfigTemplateFile = file(dockerTestContainerConfigTemplatePath)

	doLast {
		def jsonSlurper = new JsonSlurper()
		def appConfJson = jsonSlurper.parse(appConfigTemplateFile)
		def dockerConfJson = jsonSlurper.parse(dockerTestContainerConfigTemplateFile)

		def appConfKeys = appConfJson.keySet()
		def dockerConfKeys = dockerConfJson.keySet()

		// Erstelle die Menge an Schlüssel die nicht in beiden Dateien vorhanden sind
		def deltaAppToDocker = appConfKeys - dockerConfKeys
		def deltaDockerToApp = dockerConfKeys - appConfKeys
		def mergedDelta = deltaAppToDocker + deltaDockerToApp

		if ((deltaAppToDocker.size() > 0) || (deltaDockerToApp.size() > 0)) {
			throw new GradleException("Config Files für Svws-App und die ihrer Testcontainer sind inkonsistent, folgende Einträge müssen in der Docker Config in '$dockerTestContainerConfigTemplateFile.absolutePath' überprüft werden: $mergedDelta")
		}
	}
}


/**
 * Gradle-Task zur Überprüfung, ob Docker auf dem Host-System läuft.
 *
 * @throws GradleException wenn Docker nicht auf dem Host-System läuft.
 */
tasks.register('checkIfDockerIsRunning') {
	description = 'Wirft einen Fehler falls Docker nicht auf dem Host System läuft.'
	doLast {
		if ('docker info'.execute().waitFor() != 0) {
			throw new GradleException('Docker läuft nicht auf dem Host System.')
		}
	}
}


/**
 * Prüft, ob das benötigte Docker Netzwerk `gitlab_runner_network` läuft.
 * Falls nicht in CI, startet der Task das Netzwerk. Falls in CI, wirft er einen Fehler.
 *
 * @throws GradleException wenn Docker nicht auf dem Host-System läuft und der Task innerhalb von CI gestartet wurde.
 */
tasks.register('startTestDockerNetwork') {
	description = 'Prüft ob das benötigte Docker Netzwerk läuft. Falls nicht in CI, startet er den Task. Falls in CI, wirft er einen Fehler.'
	dependsOn 'checkIfDockerIsRunning'

	doLast {
		def networkExists = 'docker network ls --filter name=gitlab_runner_network -q'.execute().text.trim()
		if (networkExists) {
			println 'Docker Network `gitlab_runner_network` läuft.'
		} else {
			// Fail in CI Pipeline
			if (System.getenv('CI_SERVER')) {
				throw new GradleException('Docker Network `gitlab_runner_network` nicht verfügbar')
			}

			// Falls lokal
			println 'Docker Network `gitlab_runner_network` läuft nicht und wird gestartet.'

			// Starte das Docker Netzwerk
			def createNetwork = 'docker network create gitlab_runner_network'.execute()
			createNetwork.waitFor()
			println createNetwork.text
		}
	}
}


/**
 * Führe alle verfügbaren Integrations standardisiert gegen Docker Container aus.
 * Dieser Task macht sowohl die Vor- als auch die Nachbereitung der Tests.
 * Einstiegspunkt sowohl für die CI als auch die lokale Ausführung.
 */
tasks.register('integrationTest') {
	group = 'testing'
	description = 'Ausführung aller Integrationstests welche jeweils gegen eine temporäre standardisierte Testumgebung laufen.'

	// Überprüfe ob für die Integrationstests alle Voraussetzungen erfüllt sind
	dependsOn 'startTestDockerNetwork'
	dependsOn 'checkIfConfigFilesAreConsistent'

	// Integrationstests welche für jedes Subpackage ausgeführt werden
	// Weitere Testpackages können hier hinzugefügt werden
	dependsOn 'tests-server-api:testAgainstDockerEnv' // Vite API Tests
	dependsOn 'tests-e2e-devmode:testAgainstDockerEnv' // Playwright E2E Tests DEV Modus
	dependsOn 'tests-e2e-stablemode:testAgainstDockerEnv' // Playwright E2E Tests STABLE Modus
	dependsOn 'tests-server-dav:testAgainstDockerEnv' // Vite API Dav Tests
	dependsOn 'tests-server-enm:testAgainstDockerEnv' // Vite API ENM Tests

	if (!config.keepContainerAfterTestRun) {
		// Stoppe die Container für die jeweiligen Testumgebungen nach den Integrationstests
		finalizedBy 'tests-server-api:removeTestEnvironmentEntryPoint'
		finalizedBy 'tests-e2e-devmode:removeTestEnvironmentEntryPoint'
		finalizedBy 'tests-e2e-stablemode:removeTestEnvironmentEntryPoint'
		finalizedBy 'tests-server-dav:removeTestEnvironmentEntryPoint'
		finalizedBy 'tests-server-enm:removeTestEnvironmentEntryPoint'

		// Aggregiere die Test-Results aus allen Tests
		finalizedBy 'checkJUnitResults'
	} else {
		println("Achtung: Testcontainer werden nicht abgeräumt!")
	}
}


/**
 * Überprüft, ob die lokale SVWS-Anwendung läuft, indem sie eine HTTP-Anfrage an den lokalen Server sendet.
 * Hierfür wird das curl-Tool verwendet.
 *
 * @throws GradleException Wenn der HTTP-Antwortcode des lokalen Servers nicht 200 ist.
 */
tasks.register('checkIfLocalAppIsRunning') {
	description = 'Wirf einen Fehler wenn SVWS Server App auf dem Host System auf Port 443 läuft.'
	doFirst {
		// Führe den curl-Befehl aus und speichere die Ausgabe in einer Variable
		def process = ['curl', '-k', '-s', '-o', '/dev/null', '-w', '%{http_code}', 'https://localhost/status/alive'].execute()
		process.waitFor()

		// Lese die Ausgabe des Prozesses
		def responseCode = process.text.trim()

		if (responseCode == '200') {
			println 'SVWS Server läuft auf Port 443.'
		} else {
			throw new GradleException('Es läuft kein SVWS Server auf port 443')
		}
	}
}

/**
 * Überprüft, ob die lokale SVWS-Datenbank läuft, indem sie eine Socket-Anfrage an den lokalen DB-Server sendet.
 *
 * @throws GradleException Wenn keine Datenbank mit offenem Socket auf 3306 läuft.
 */
tasks.register('checkIfLocalDatabaseIsRunning') {
	description = 'Wirf einen Fehler wenn keine MariaDB auf dem Host System auf Port 3306 läuft.'
	doLast {
		def socket = new Socket()
		try {
			socket.connect(new InetSocketAddress('localhost', 3306), 2000)
			println 'MariaDB Database auf port 3306 erreichbar.'
		} catch (IOException ignored) {
			throw new GradleException('Es läuft keine MariaDB auf port 3306.')
		} finally {
			try {
				socket.close()
			} catch (IOException ignored) {
			}
		}
	}
}


/**
 * Integrationstests. Hier werden alle verfügbaren lokal Integrations ausgeführt.
 *
 * Dies Test laufen gehen die lokale unabhängig gestartete Datenbank und SVWS App. Es werden keine Docker Container im Hintergrund als Testumgebung gestartet.
 * Läuft also das Backend oder die Datenbank nicht, kann dieser Task nicht verwendet werden.
 */
tasks.register('no_auto_docker_integrationTest') {
	description = 'Führt die integrations gegen das laufende Backed + Datenbank aus. Diese werden daher benötigt und sollten vorher manuel gestartet werden'
	group = 'testing'

	// Prüfe ob Voraussetzungen erfüllt sind
	dependsOn ':tests:checkIfLocalAppIsRunning'
	dependsOn ':tests:checkIfLocalDatabaseIsRunning'

	// Führe die lokalen Tests der jeweiligen Subpackages aus
	dependsOn 'tests-server-api:no_auto_docker_test_APIServer' // VITE API Tests
/*	dependsOn 'tests-server-dav:no_auto_docker_test_DAV' // VITE API DAV Tests
	dependsOn 'tests-e2e-devmode:no_auto_docker_test_E2E' // Ende zu Ende Tests
	dependsOn 'tests-e2e-stablemode:no_auto_docker_test_E2E' // Ende zu Ende Tests*/

}


/**
 * Untersucht die JUnit-Ergebnisse nach dem Ausführen der Tests. Iteriert durch alle JUnits Reports.
 *
 * @throws GradleException falls ein beliebiger Integrationstest fehlgeschlagen ist.
 */
tasks.register('checkJUnitResults') {
	// Die Tests sollten komplett abgeschlossen (und rückgebaut) werden bevor die Ergebnisse evaluiert werden
	mustRunAfter 'tests-server-api:removeTestEnvironmentEntryPoint'
	mustRunAfter 'tests-e2e-devmode:removeTestEnvironmentEntryPoint'
	mustRunAfter 'tests-e2e-stablemode:removeTestEnvironmentEntryPoint'
	mustRunAfter 'tests-server-dav:removeTestEnvironmentEntryPoint'
	mustRunAfter 'tests-server-enm:removeTestEnvironmentEntryPoint'

	// Die Liste der JUnit Report Files. Hier sollten neue Einträge ergänzt werden wenn weitere Testpackages geschrieben werden.
	def junitReportFiles = [
			'tests-server-api/build/test-results/api-test-results.xml',
			'tests-e2e-devmode/build/test-results/zusammenfassung/e2e-results.xml',
			'tests-e2e-stablemode/build/test-results/zusammenfassung/e2e-results.xml',
			'tests-server-dav/build/test-results/api-test-results.xml',
			'tests-server-enm/build/test-results/after-setup-test-results.xml',
			'tests-server-enm/build/test-results/setup-test-results.xml',
			'tests-server-enm/build/test-results/sync-test-results.xml'
	]
	doLast {
		int totalTests = 0
		int totalErroredTests = 0
		int totalSkippedTests = 0

		junitReportFiles.each { filePath ->
			// Lade die JUnit Report Datei
			def junitReportFile = file(filePath)

			if (!junitReportFile.exists()) {
				throw new GradleException("JUnit Report Datei: ${junitReportFile}")
			}

			// Zähle für jeden JUnit Report file die entsprechenden Einträge
			def report = new XmlSlurper().parse(junitReportFile)
			def testCases = report.'**'.findAll { it.name() == 'testcase' }
			def erroredTests = testCases.findAll { it.error.size() > 0 }
			def failedTests = testCases.findAll { it.failure.size() > 0 }
			def skippedTests = testCases.findAll { it.skipped.size() > 0 }

			totalTests += testCases.size()
			totalErroredTests += erroredTests.size() + failedTests.size()
			totalSkippedTests += skippedTests.size()
		}

		// Print Debug Info für die Auswertung der Integrationstests. Fall es Test fehlgeschlagen ist wirf einen Fehler (damit die Pipeline fehlschlägt)
		if (totalErroredTests > 0) {
			throw new GradleException("Integrationstests insgesamt: ${totalTests} | Skipped: ${totalSkippedTests} | Error: ${totalErroredTests}")
		} else {
			// Log in grüner Schrift anzeigen
			def highlightGreen = { text -> "\033[32m${text}\033[0m" }

			println("${highlightGreen('\n****************************************************************')}")
			println("Alle ${totalTests} Integrationstests waren fehlerfrei. (Skipped: ${totalSkippedTests})")
			println("${highlightGreen('****************************************************************\n')}")
		}
	}
}

