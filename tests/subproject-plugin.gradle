import groovy.json.JsonSlurper
import svws.gradle.scripts.FileUtils

/*
* Alle Tasks in dieser Datei werden in den jeweiligen Unterpaketen ausgeführt.
*/

dependencies {
	implementation project(':svws-server-app')
}

def buildDirPath = layout.buildDirectory.get()

def configDir = "${rootDir}/config/tests"
def configFile = file("$configDir/config.json").exists() ? file("$configDir/config.json") : file("$configDir/config_default.json")
def config = new JsonSlurper().parse(configFile)

if (!rootProject.ext.has('APP_BASE_IMAGE_NAME')) {
	rootProject.ext.APP_BASE_IMAGE_NAME = "svws-app-base:" + (System.getenv('CI_COMMIT_SHORT_SHA') ?: UUID.randomUUID().toString().substring(0, 8))
}

if (!rootProject.ext.has('CONTAINER_NAME_SUFFIX')) {
	rootProject.ext.CONTAINER_NAME_SUFFIX = System.getenv('CI_SERVER') ? "-${System.getenv('CI_JOB_ID')}-${System.getenv('CI_COMMIT_SHORT_SHA')}" : '-local'
}


/**
 * Dieser Task generiert die Docker-Compose-Datei für die Testumgebung. Dabei wird ein Template geladen und entsprechende Platzhalter durch Variablen in Gradle ersetzt.
 */
tasks.register('generateDockerComposeFile') {
	description = 'Generiert die Docker-Compose-Datei für die Testumgebung'
	dependsOn 'buildDockerImage'

	def DB_CONTAINER_NAME = project.ext.DB_CONTAINER_NAME
	def APP_CONTAINER_NAME = project.ext.APP_CONTAINER_NAME
	def TARGET_TEST_DATABASES = project.ext.TARGET_TEST_DATABASES
	def DB_SERVICE_NAME = project.ext.DB_SERVICE_NAME
	def APP_IMAGE_NAME = project.ext.APP_IMAGE_NAME
	def FORWARDED_DB_PORT = project.ext.FORWARDED_DB_PORT
	def FORWARDED_APP_PORT = project.ext.FORWARDED_APP_PORT

	def inputFile = file('../templates/docker/compose.yml.template')
	def outputFile = file("$buildDirPath/tempdocker/compose.yml")
	def dbImageName = "${config.dockerRegistry}/svws-datenbank/${TARGET_TEST_DATABASES.first().toLowerCase()}:latest"

	doLast {

		def replacements = [
				'#GRADLE_PLACEHOLDER_DB_CONTAINER_NAME' : "container_name: ${DB_CONTAINER_NAME}",
				'#GRADLE_PLACEHOLDER_APP_CONTAINER_NAME': "container_name: ${APP_CONTAINER_NAME}",
				'#GRADLE_PLACEHOLDER_DEFAULT_SCHEMA'    : "${TARGET_TEST_DATABASES.first()}",
				'#GRADLE_PLACEHOLDER_DB_SERVICE_NAME'   : "${DB_SERVICE_NAME}",
				'#GRADLE_PLACEHOLDER_DB_IMAGE_NAME'     : "${dbImageName}",
				'#GRADLE_PLACEHOLDER_APP_IMAGE_NAME'    : "${APP_IMAGE_NAME}",
				'#GRADLE_PLACEHOLDER_DOCKER_REG_URL'    : "${config.dockerRegistry}"
		]

		FileUtils.replaceFilePlaceholderWithValues(inputFile, outputFile, replacements)

		if (!System.getenv('CI_SERVER')) {
			def replacementsLokal = [
					'#GRADLE_PLACEHOLDER_MARIADB_FORWARDING_PORT': "ports:\n      - \"${FORWARDED_DB_PORT}:3306\"",
					'#GRADLE_PLACEHOLDER_APP_FORWARDING_PORT'    : "ports:\n      - \"${FORWARDED_APP_PORT}:8443\"",
			]

			FileUtils.replaceFilePlaceholderWithValues(outputFile, outputFile, replacementsLokal)
		}
	}
}


/**
 * Dieser Task generiert die Dockerfile-Datei für die Testumgebung. Dabei wird ein Template geladen und entsprechende Platzhalter durch Variablen in Gradle ersetzt.
 */

tasks.register('generateAppDockerfile') {
	description = 'Generiert die Dockerfile-Datei für die Testumgebung'
	dependsOn 'erzeugeOrdnerFuerTestumgebung'

	def ENM_CONTAINER_NAME = project.ext.has('ENM_CONTAINER_NAME') ? project.ext.ENM_CONTAINER_NAME : "localhost"
	def inputFile = file('../templates/docker/template.app.dockerfile')
	def outputFile = file("$buildDirPath/tempdocker/app.dockerfile")

	doLast {

		def replacements = [
				'GRADLE_PLACEHOLDER_ENM_HOST'           : "${ENM_CONTAINER_NAME}",
				'GRADLE_PLACEHOLDER_APP_BASE_IMAGE_NAME': "${rootProject.ext.APP_BASE_IMAGE_NAME}",
		]

		FileUtils.replaceFilePlaceholderWithValues(inputFile, outputFile, replacements)
	}
}

/**
 * Dieser Task generiert das Shell-Skript zum Erstellen des Keystores für den SVWS-Server.
 */
tasks.register('generateKeyStoreScript') {
	description = 'Generiert das Shell-Skript zum Erstellen des Keystores für den SVWS-Server'
	dependsOn 'erzeugeOrdnerFuerTestumgebung'

	doLast {
		def outputFile = file("$buildDirPath/tempdocker/init-scripts/create-keystore.sh")

		def targetIp = System.getenv('CI_SERVER') ? "${APP_CONTAINER_NAME}" : "localhost"
		def content = "keytool -genkey -noprompt -alias svwslocaltestcontainer -dname \"CN=${targetIp}, OU=test, O=test, L=test, S=test, C=test\" -keystore /etc/app/svws/conf/keystore -storepass changeit -keypass changeit  -keyalg RSA"

		FileUtils.writeFile(outputFile, content)
	}
}


/**
 * Dieser Task generiert die Konfigurationsdatei für den SVWS-Server. Dabei wird ein Template geladen und entsprechende Platzhalter durch Variablen in Gradle ersetzt.
 */
tasks.register('generateSvwsConfigFile') {
	description = 'Generiert die Konfigurationsdatei für den SVWS-Server'
	dependsOn 'erzeugeOrdnerFuerTestumgebung'

	def DB_CONTAINER_NAME = project.ext.DB_CONTAINER_NAME
	def TARGET_TEST_DATABASES = project.ext.TARGET_TEST_DATABASES
	def SERVERMODE = project.ext.SVWS_SERVERMODE
	doFirst {
		delete(fileTree("$buildDirPath/tempdocker/appConf/svws_config.json.template"))
	}

	doLast {
		def inputFile = file('../templates/config/svws_config.json.template')
		def outputFile = file("$buildDirPath/tempdocker/appConf/svws_config.json.template")

		def replacements = [
				'GRADLE_PLACEHOLDER_SERVER_MODE'      : "${SERVERMODE}",
				'GRADLE_PLACEHOLDER_DB_CONTAINER_NAME': "${DB_CONTAINER_NAME}",
				'GRADLE_PLACEHOLDER_DEFAULT_SCHEMA'   : "${TARGET_TEST_DATABASES.first()}"
		]

		FileUtils.replaceFilePlaceholderWithValues(inputFile, outputFile, replacements)
	}
}


/**
 * Dieser Task generiert das Start-Skript für den SVWS-Server.
 */
tasks.register('generateStartupScript') {
	description = 'Generiert das Start-Skript für den SVWS-Server'
	dependsOn 'erzeugeOrdnerFuerTestumgebung'

	doLast {
		def outputFile = file("$buildDirPath/tempdocker/init-scripts/startup.sh")
		def content =
				"""
			#!/bin/bash

			# Dieses Skript wird in jedem Testcontainer ausgeführt sobald dieser gestartet wird,

			# Konfigurationsdatei generieren
			envsubst < /etc/app/svws/conf/svws_config.json.template > /opt/app/svws/svwsconfig.json

			/bin/bash "/etc/app/svws/init-scripts/create-keystore.sh"

			echo "Starte SVWS-Server ..."
			java -cp "svws-server-app-*.jar:./*:./lib/*" de.svws_nrw.server.jetty.Main
			"""

		FileUtils.writeFile(outputFile, content)
	}
}


/**
 * Erstellt die Ordner für die Testumgebung bzw. die Docker Container.
 */
tasks.register('erzeugeOrdnerFuerTestumgebung') {
	description = 'Erstellt die Ordner für die Testumgebung bzw. die Docker Container'

	doFirst {
		mkdir "$buildDirPath/tempdocker"
		mkdir "$buildDirPath/tempdocker/init-scripts"
		mkdir "$buildDirPath/tempdocker/appConf"
	}
}

// Ansammlung aller Tasks welche die Dateien für die Docker Images bereit stellen.
tasks.register('generateScripts') {
	description = 'Generiert alle Dateien für die Docker-Images'
	dependsOn 'generateAppDockerfile'
	dependsOn 'generateKeyStoreScript'
	dependsOn 'generateSvwsConfigFile'
	dependsOn 'generateStartupScript'
}

// Erstellt das Docker-Image für die Testumgebung in den Unterprojekten.
tasks.register('buildDockerImage', Exec) {
	description = 'Erstellen des Docker-Images für die Testumgebung'
	dependsOn 'generateScripts'
	dependsOn ':tests:buildAppBaseDockerImage'

	commandLine 'docker', 'build', '-t', "${APP_IMAGE_NAME}", '-f', "$buildDirPath/tempdocker/app.dockerfile", '.'
}


// Startet die Docker-Container für die Testumgebung.
tasks.register('starteDockerContainerMitTestUmgebung', Exec) {
	description = 'Starten der Datenbank und des SVWS-Servers im Docker'
	dependsOn 'generateDockerComposeFile'
	dependsOn ':tests:startTestDockerNetwork'
	workingDir "$buildDirPath/tempdocker"

	commandLine 'docker', 'compose', '-p', "svws-$project.name", 'up', '--wait'
}


/**
 * Stoppt die Docker-Container für die Testumgebung.
 */
tasks.register('stoppeDockerContainerTestUmgebung', Exec) {
	group = 'testing'
	description = 'Stoppen der Container der Testumgebung'
	workingDir "$buildDirPath/tempdocker"
	commandLine 'docker', 'compose', '-p', "svws-$project.name", 'down', '-v'
}


/**
 * Löscht das Docker-Netzwerk namens gitlab_runner_network.
 */
tasks.register('deleteDockerNetwork') {
	description = 'Löscht das Docker-Netzwerk namens gitlab_runner_network'
	dependsOn 'stoppeDockerContainerTestUmgebung'
	doLast {
		def process = 'docker network rm gitlab_runner_network'.execute()
		process.waitFor()
		println process.text
	}
}

tasks.register('removeTestEnvironmentEntryPoint') {
	dependsOn 'deleteDockerNetwork'
}

