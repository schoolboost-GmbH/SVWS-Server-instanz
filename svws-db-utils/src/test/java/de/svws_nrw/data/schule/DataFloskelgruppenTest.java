package de.svws_nrw.data.schule;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import de.svws_nrw.asd.data.RGBFarbe;
import de.svws_nrw.asd.utils.ASDCoreTypeUtils;
import de.svws_nrw.core.data.schule.Floskelgruppe;
import de.svws_nrw.db.DBEntityManager;
import de.svws_nrw.db.dto.current.katalog.DTOFloskelgruppen;
import de.svws_nrw.db.utils.ApiOperationException;
import jakarta.ws.rs.core.Response;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatException;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;


@ExtendWith(MockitoExtension.class)
@DisplayName("Diese Klasse testet die Klasse DataFloskelgruppen")
class DataFloskelgruppenTest {

	@Mock
	private DBEntityManager conn;

	@InjectMocks
	private DataFloskelgruppen data;

	@BeforeAll
	static void setUp() {
		ASDCoreTypeUtils.initAll();
	}

	@Test
	@DisplayName("setAttributesRequiredOnCreation: kuerzel")
	void setAttributesRequiredOnCreationTest() {
		assertThatException()
				.isThrownBy(() -> this.data.add(Map.of("bezeichnung", "test")))
				.isInstanceOf(ApiOperationException.class)
				.withMessage("Es werden weitere Attribute (kuerzel) benötigt, damit die Entität erstellt werden kann.")
				.hasFieldOrPropertyWithValue("status", Response.Status.BAD_REQUEST);
	}

	@Test
	@DisplayName("setAttributesNotPatchable: id")
	void setAttributesNotPatchableTest() {
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 1L)).thenReturn(mock(DTOFloskelgruppen.class));

		assertThatException()
				.isThrownBy(() -> this.data.patch(1L, Map.of("id", "test")))
				.isInstanceOf(ApiOperationException.class)
				.withMessage("Folgende Attribute werden für ein Patch nicht zugelassen: id.")
				.hasFieldOrPropertyWithValue("status", Response.Status.BAD_REQUEST);
	}

	@Test
	@DisplayName("initDTO | id is assigned")
	void initDTO_idIsAssigned() {
		final var dto = new DTOFloskelgruppen(-1L, "kuerzel", "bez");

		this.data.initDTO(dto, 2L, Collections.emptyMap());

		assertThat(dto.ID).isEqualTo(2L);
	}

	@Test
	@DisplayName("getLongId")
	void getLongId() throws ApiOperationException {
		final var dto = new DTOFloskelgruppen(2L, "kuerzel", "bez");

		assertThat(this.data.getLongId(dto)).isEqualTo(2);
	}

	@Test
	@DisplayName("getById | Id is null")
	void getByIdTest_idIsNull() {
		assertThatException()
				.isThrownBy(() -> this.data.getById(null))
				.isInstanceOf(ApiOperationException.class)
				.withMessage("Die ID für die Floskelgruppe darf nicht null sein.")
				.hasFieldOrPropertyWithValue("status", Response.Status.BAD_REQUEST);
	}

	@Test
	@DisplayName("getById | no entry found")
	void getByIdTest_noEntryFound() {
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 1L)).thenReturn(null);

		assertThatException()
				.isThrownBy(() -> this.data.getById(1L))
				.isInstanceOf(ApiOperationException.class)
				.withMessage("Es wurde keine Floskelgruppe mit der ID 1 gefunden.")
				.hasFieldOrPropertyWithValue("status", Response.Status.NOT_FOUND);
	}

	@Test
	@DisplayName("getById")
	void getByIdTest() throws ApiOperationException {
		final var dto = new DTOFloskelgruppen(1L, "kuerzel", "bez");
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 1L)).thenReturn(dto);

		assertThat(this.data.getById(1L))
				.isInstanceOf(Floskelgruppe.class)
				.hasFieldOrPropertyWithValue("id", 1L)
				.hasFieldOrPropertyWithValue("kuerzel", "kuerzel")
				.hasFieldOrPropertyWithValue("bezeichnung", "bez");
	}

	@Test
	@DisplayName("getAll | no entries found")
	void getAllTest_noEntriesFound() {
		when(this.conn.queryAll(DTOFloskelgruppen.class)).thenReturn(Collections.emptyList());

		assertThat(this.data.getAll()).isEmpty();
	}

	@Test
	@DisplayName("getAll")
	void getAllTest() {
		final var dto = new DTOFloskelgruppen(1L, "k1", "b1");
		final var dto2 = new DTOFloskelgruppen(2L, "k2", "b2");
		when(this.conn.queryAll(DTOFloskelgruppen.class)).thenReturn(List.of(dto, dto2));

		assertThat(this.data.getAll())
				.hasSize(2)
				.satisfiesExactly(
						f1 -> assertThat(f1)
								.hasFieldOrPropertyWithValue("id", 1L)
								.hasFieldOrPropertyWithValue("kuerzel", "k1")
								.hasFieldOrPropertyWithValue("bezeichnung", "b1"),
						f2 -> assertThat(f2)
								.hasFieldOrPropertyWithValue("id", 2L)
								.hasFieldOrPropertyWithValue("kuerzel", "k2")
								.hasFieldOrPropertyWithValue("bezeichnung", "b2")
				);
	}

	@Test
	@DisplayName("map")
	void mapTest() {
		final var dto = new DTOFloskelgruppen(1L, "kuerz", "bez");
		dto.Hauptgruppe_ID = 2L;
		dto.Farbe = 2785280;

		assertThat(this.data.map(dto))
				.isInstanceOf(Floskelgruppe.class)
				.hasFieldOrPropertyWithValue("id", 1L)
				.hasFieldOrPropertyWithValue("kuerzel", "kuerz")
				.hasFieldOrPropertyWithValue("bezeichnung", "bez")
				.hasFieldOrPropertyWithValue("idFloskelgruppenart", 2L)
				.satisfies(f -> assertThat(f.farbe)
						.hasFieldOrPropertyWithValue("red", 42)
						.hasFieldOrPropertyWithValue("green", 128)
						.hasFieldOrPropertyWithValue("blue", 0)
				);
	}

	@Test
	@DisplayName("map | farbe is null")
	void mapTest_farbeIsNull() {
		final var dto = new DTOFloskelgruppen(1L, "kuerz", "bez");
		dto.Farbe = null;

		assertThat(this.data.map(dto))
				.isInstanceOf(Floskelgruppe.class)
				.hasFieldOrPropertyWithValue("farbe", null);
	}

	@Test
	@DisplayName("patch | kuerzel | no changes")
	void patch_kuerzelNoChanges() throws ApiOperationException {
		final var dto = new DTOFloskelgruppen(1L, "same", "bez");
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 1L)).thenReturn(dto);
		when(this.conn.transactionPersist(dto)).thenReturn(true);

		this.data.patch(1L, Map.of("kuerzel", "same"));

		verify(this.conn, never()).queryAll(DTOFloskelgruppen.class);
		assertThat(dto.Kuerzel).isEqualTo("same");
	}

	@Test
	@DisplayName("patch | kuerzel | isBlank")
	void patch_kuerzelIsBlank() throws ApiOperationException {
		final var dto = new DTOFloskelgruppen(1L, "same", "bez");
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 1L)).thenReturn(dto);
		when(this.conn.transactionPersist(dto)).thenReturn(true);

		this.data.patch(1L, Map.of("kuerzel", "  "));

		verify(this.conn, never()).queryAll(DTOFloskelgruppen.class);
		assertThat(dto.Kuerzel).isEqualTo("same");
	}

	@Test
	@DisplayName("patch | kuerzel already Used")
	void patch_kuerzelAlreadyUsed() {
		final var dto = new DTOFloskelgruppen(1L, "first", "bez");
		final var dto2 = new DTOFloskelgruppen(2L, "second", "bez");
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 2L)).thenReturn(dto2);
		when(this.conn.queryAll(DTOFloskelgruppen.class)).thenReturn(List.of(dto, dto2));

		assertThatException()
				.isThrownBy(() -> this.data.patch(2L, Map.of("kuerzel", "first")))
				.isInstanceOf(ApiOperationException.class)
				.withMessage("Das Kürzel first wird bereits verwendet.")
				.hasFieldOrPropertyWithValue("status", Response.Status.BAD_REQUEST);
	}

	@Test
	@DisplayName("patch | kuerzel already Used | upper case")
	void patch_kuerzelAlreadyUsed_upperCase() {
		final var dto = new DTOFloskelgruppen(1L, "first", "bez");
		final var dto2 = new DTOFloskelgruppen(2L, "second", "bez");
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 2L)).thenReturn(dto2);
		when(this.conn.queryAll(DTOFloskelgruppen.class)).thenReturn(List.of(dto, dto2));

		assertThatException()
				.isThrownBy(() -> this.data.patch(2L, Map.of("kuerzel", "FIRST")))
				.isInstanceOf(ApiOperationException.class)
				.withMessage("Das Kürzel FIRST wird bereits verwendet.")
				.hasFieldOrPropertyWithValue("status", Response.Status.BAD_REQUEST);
	}

	@Test
	@DisplayName("patch | kuerzel")
	void patch_kuerzel() throws ApiOperationException {
		final var dto = new DTOFloskelgruppen(1L, "first", "bez");
		final var dto2 = new DTOFloskelgruppen(2L, "second", "bez");
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 2L)).thenReturn(dto2);
		when(this.conn.queryAll(DTOFloskelgruppen.class)).thenReturn(List.of(dto, dto2));
		when(this.conn.transactionPersist(dto2)).thenReturn(true);

		this.data.patch(2L, Map.of("kuerzel", "third"));

		assertThat(dto2.Kuerzel).isEqualTo("third");
	}

	@Test
	@DisplayName("patch | bezeichnung | null")
	void patch_bezeichnung_null() {
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 2L)).thenReturn(mock(DTOFloskelgruppen.class));
		final var input = new HashMap<String, Object>();
		input.put("bezeichnung", null);

		assertThatException()
				.isThrownBy(() -> this.data.patch(2L, input))
				.withMessage("Attribut bezeichnung: Der Wert null ist nicht erlaubt.")
				.hasFieldOrPropertyWithValue("status", Response.Status.BAD_REQUEST);
	}

	@Test
	@DisplayName("patch | bezeichnung | empty")
	void patch_bezeichnung_empty() {
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 2L)).thenReturn(mock(DTOFloskelgruppen.class));

		assertThatException()
				.isThrownBy(() -> this.data.patch(2L, Map.of("bezeichnung", "")))
				.withMessage("Attribut bezeichnung: Ein leerer String ist hier nicht erlaubt.")
				.hasFieldOrPropertyWithValue("status", Response.Status.BAD_REQUEST);
	}

	@Test
	@DisplayName("patch | bezeichnung | tooLong")
	void patch_bezeichnung_tooLong() {
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 2L)).thenReturn(mock(DTOFloskelgruppen.class));

		assertThatException()
				.isThrownBy(() -> this.data.patch(2L, Map.of("bezeichnung", "Lorem ipsum dolor sit amet, consetetur sadipscing e")))
				.withMessage("Attribut bezeichnung: Die Länge des Strings ist auf 50 Zeichen limitiert.")
				.hasFieldOrPropertyWithValue("status", Response.Status.BAD_REQUEST);
	}

	@Test
	@DisplayName("patch | bezeichnung")
	void patch_bezeichnung() throws ApiOperationException {
		final var dto = new DTOFloskelgruppen(1L, "kuerz", "bez");
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 1L)).thenReturn(dto);
		when(this.conn.transactionPersist(dto)).thenReturn(true);

		this.data.patch(1L, Map.of("bezeichnung", "neueBezeichnung"));

		assertThat(dto.Bezeichnung).isEqualTo("neueBezeichnung");
	}

	@Test
	@DisplayName("patch | idFloskelgruppenart | null")
	void patch_idFloskelgruppenart_null() throws ApiOperationException {
		final var dto = new DTOFloskelgruppen(1L, "kuerz", "bez");
		dto.Hauptgruppe_ID = 42L;
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 1L)).thenReturn(dto);
		when(this.conn.transactionPersist(dto)).thenReturn(true);
		final var map = new HashMap<String, Object>();
		map.put("idFloskelgruppenart", null);

		this.data.patch(1L, map);

		assertThat(dto.Hauptgruppe_ID).isNull();
	}

	@Test
	@DisplayName("patch | IdFloskelgruppenart | not found")
	void patch_IdFloskelgruppenart_notFound() {
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 1L)).thenReturn(mock(DTOFloskelgruppen.class));

		assertThatException()
				.isThrownBy(() -> this.data.patch(1L, Map.of("idFloskelgruppenart", -1L)))
				.isInstanceOf(ApiOperationException.class)
				.withMessage("Es wurde keine Floskelgruppenart zur ID -1 gefunden.")
				.hasFieldOrPropertyWithValue("status", Response.Status.NOT_FOUND);
	}

	@Test
	@DisplayName("patch | idFloskelgruppenart | no change")
	void patch_IdFloskelgruppenart_noChange() throws ApiOperationException {
		final var dto = new DTOFloskelgruppen(1L, "kuerz", "bez");
		dto.Hauptgruppe_ID = 2L;
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 1L)).thenReturn(dto);
		when(this.conn.transactionPersist(dto)).thenReturn(true);

		this.data.patch(1L, Map.of("idFloskelgruppenart", 2L));

		assertThat(dto.Hauptgruppe_ID).isEqualTo(2L);
	}

	@Test
	@DisplayName("patch | idFloskelgruppenart")
	void patch_IdFloskelgruppenart() throws ApiOperationException {
		final var dto = new DTOFloskelgruppen(1L, "kuerz", "bez");
		dto.Hauptgruppe_ID = 2L;
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 1L)).thenReturn(dto);
		when(this.conn.transactionPersist(dto)).thenReturn(true);

		this.data.patch(1L, Map.of("idFloskelgruppenart", 3L));

		assertThat(dto.Hauptgruppe_ID).isEqualTo(3L);
	}

	@Test
	@DisplayName("patch | updateFarbe | wrong type")
	void patch_updateFarbe_wrongType() {
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 1L)).thenReturn(mock(DTOFloskelgruppen.class));

		assertThatException()
				.isThrownBy(() -> this.data.patch(1L, Map.of("farbe", "das ist kein RGBFarbe Objekt")))
				.isInstanceOf(ApiOperationException.class)
				.withMessageStartingWith("Die Farbe entspricht nicht dem richtigen Datentyp:")
				.hasFieldOrPropertyWithValue("status", Response.Status.BAD_REQUEST);
	}

	@Test
	@DisplayName("patch | updateFarbe | null")
	void patch_updateFarbe_null() throws ApiOperationException {
		final var dto = new DTOFloskelgruppen(1L, "kuerz", "bez");
		dto.Farbe = 42;
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 1L)).thenReturn(dto);
		when(this.conn.transactionPersist(dto)).thenReturn(true);
		final var map = new HashMap<String, Object>();
		map.put("farbe", null);

		this.data.patch(1L, map);

		assertThat(dto.Farbe).isNull();
	}


	@Test
	@DisplayName("patch | unknown argument")
	void patch_unknownArgument() {
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 1L)).thenReturn(mock(DTOFloskelgruppen.class));

		assertThatException()
				.isThrownBy(() -> this.data.patch(1L, Map.of("unknown", "unknown")))
				.isInstanceOf(ApiOperationException.class)
				.withMessage("Die Daten des Patches enthalten das unbekannte Attribut unknown.")
				.hasFieldOrPropertyWithValue("status", Response.Status.BAD_REQUEST);
	}

	@Test
	@DisplayName("patch | updateFarbe")
	void patch_updateFarbe() throws ApiOperationException {
		final var dto = new DTOFloskelgruppen(1L, "kuerzel", "allgemein");
		when(this.conn.queryByKey(DTOFloskelgruppen.class, 1L)).thenReturn(dto);
		when(this.conn.transactionPersist(dto)).thenReturn(true);

		this.data.patch(1L, Map.of("farbe", new RGBFarbe(128, 128, 0)));

		assertThat(dto.Farbe).isEqualTo(8421376);
	}

}
